# Computation Graph

Это библиотека для организации вычислений над таблицами. С её помощью можно задавать последовательности операций в виде графа вычислений, а затем запускать полученные графы, считывая данные из одного файла и записывая результат в другой. Таблицы задаются последовательностью словарей dict.

## 1. Операции

Поддерживаются 6 типов операций: Map, Reduce, Join, Fold, Sort, Input.

### 1.1 Map(mapper)

Вызывает функцию mapper от каждой из строк таблицы. Функция mapper должна быть генератором. Она принимает строку исходной таблицы и выдаёт новую строку или набор строк.

### 1.2 Reduce(reducer, key)

Группирует строки по группам с общим ключом или набором ключей key, затем от каждой группы строк вызывает reducer. При этом функция reducer должна быть генератором, принимающим набор строк и выдающим строку или набор строк. Перед вызовом операции Reduce необходимо отсортировать таблицу по соответствубщему ключу key.

### 1.3 Join(graph, key, strategy)

Эта операция соединяет граф, в котором находится, с новым графом graph по ключу(или набору ключей) key. Возможно 5 вариантов, или стратегий: inner, left, right, full, cross. Описание операций можно найти на https://ru.wikipedia.org/wiki/Join_(SQL).

### 1.4 Fold(folder, start_state)

Поледовательно вызывает folder от всех строк таблицы. folder -- функция, которая принимает состояние state и строку row и возвращает обновлённое состояние.

### 1.5 Sort(key)

Сортирует таблицу по ключу или набору ключей key лексикографически.

### 1.6 Input(source)

Задаёт вход для данного графа. Входом может быть открытый на чтение текстовый файл или другой граф. Особенности Input см. ниже в разделе интерфейс, задание графа.


## 2. Интерфейс

Общая схема работы с библиотекой такова:
1) Задать граф
2) Скомпилировать граф
3) Запустить граф

### 2.1 Задание графа

Каждый граф есть линейная последовательность операций. При этом выполнение некоторых операций может зависеть от других графов. 

Есть два способа задавать граф: с помощью метода add и с "через точку". Примеры:

1) Через add 
```python
graph = mrop.ComputeGraph()
graph.add(Map(mapper))
graph.add(Sort('my_key'))
graph.add(Reduce(reducer, 'my_key'))
```

2) "Через точку"
```python
count_idf = mrop.ComputeGraph() \
    .input(split_word) \
    .sort(['doc_id', 'word']) \
    .reduce(reducer_unique, ['doc_id', 'word']) \
    .join(count_docs, strategy='cross') \
    .sort('word') \
    .reduce(reducer_calc_idf, 'word')
```

Методы __init__ классов Map, Reduce, ... принимают на вход то же, что и методы map, reduce, ... класса ComputeGraph.

Примечание об Input. В отличие от других операций, вход можно задавать как перед компиляцией (compile), так и во время начала вычислений (run). Если вход задаётся перед compile, то на этапе run его уже нельзя изменить. Кроме того, если входом является другой граф, то его можно задать только перед compile, а при вызове run нельзя.

### 2.2 Компиляция графа

Необходимо провести провести перед запуском графа, т.к. во время компиляции определяется порядок действий. Производится с помощью вызова compile() без аргументов. ПАРАМЕТР topsort_needed НЕ ПРЕДНАЗНАЧЕН ДЛЯ ИСПОЛЬЗОВАНИЯ ПОЛЬЗОВАТЕЛЕМ, И ЕГО ИЗМЕНЕНИЕ ПРИВЕДЁТ К НЕОПРЕДЕЛЁННОМУ ПОВЕДЕНИЮ.

Граф можно скомпилировать только один раз. После компиляции нельзя добавлять новые операции.

### Запуск графа

Вызвается с помощью метода run(). Для вычисления необоходимо, чтобы для графа и для всех графов, от которых он зависит, были заданы входы (параметры input, subgraph_inputs). Входом может быть другой граф или же открытый файл. Если входом является другой граф, его необходимо задать до compile. Если входом является файл, то его можно задать и до compile, и во время run. При этом входы, заданные до compile, нельзя перезадать во время run.

Примечание. Если у двух подграфов входом является один и тот же один и тот же файл (именно файл, а не граф), то библиотека позволяет избежать повторного чтения.

Пример вызова, который приведёт к повторному чтению:

```python
source = 'input.txt'
subgraph_sources = {
    split_word: open(source, 'r'),
    count_docs: open(source, 'r')
}
calc_index.run(output=open(output, 'w'), subgraph_inputs=subgraph_sources, verbose=1)
```

Пример правильного вызова:

```python
source = 'input.txt'
with open(source, 'r') as in_file:
    subgraph_sources = {
        split_word: in_file,
        count_docs: in_file
    }
    calc_index.run(output=open(output, 'w'), subgraph_inputs=subgraph_sources, verbose=1)
```

